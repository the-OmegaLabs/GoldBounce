/*
 * GoldBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/bzym2/GoldBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import com.google.common.collect.Iterables
import com.google.common.collect.Lists
import net.ccbluex.liquidbounce.LiquidBounce.hud
import net.ccbluex.liquidbounce.bzym.IAccessorGuiIngame
import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.hud.WaterMark
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.utils.MovementUtils.airTicks
import net.ccbluex.liquidbounce.utils.PPSCounter
import net.ccbluex.liquidbounce.utils.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.ReflectionUtil
import net.ccbluex.liquidbounce.utils.chat
import net.ccbluex.liquidbounce.utils.extensions.isInLiquid
import net.ccbluex.liquidbounce.utils.extensions.isMoving
import net.ccbluex.liquidbounce.utils.extensions.tryJump
import net.ccbluex.liquidbounce.utils.inventory.InventoryUtils
import net.ccbluex.liquidbounce.utils.timing.MSTimer
import net.ccbluex.liquidbounce.value.*
import net.minecraft.client.gui.ScaledResolution
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.init.Items
import net.minecraft.item.ItemStack
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S07PacketRespawn
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import net.minecraft.network.play.server.S32PacketConfirmTransaction
import net.minecraft.potion.Potion
import net.minecraft.scoreboard.Score
import net.minecraft.scoreboard.ScorePlayerTeam
import net.minecraft.scoreboard.Scoreboard
import net.minecraft.util.ResourceLocation
import net.minecraft.util.StringUtils
import net.minecraftforge.event.entity.EntityJoinWorldEvent
import net.minecraftforge.fml.common.eventhandler.SubscribeEvent
import org.lwjgl.opengl.GL11.*
import java.awt.Color
import java.util.*
import java.util.concurrent.LinkedBlockingQueue
import kotlin.math.cos
import kotlin.math.sin
import kotlin.math.sqrt

object Disabler : Module("Disabler", Category.EXPLOIT, hideModule = false) {
    val mode by ListValue("Mode", arrayOf("Hypixel", "Normal", "Basic"), "Normal")
    private val hypixelMode by BoolValue("Hypixel", true) { mode == "Hypixel" }
    private val activationDelay by FloatValue("Activation delay", 0.0F, 0.0F..4.0F) { mode == "Hypixel" }
    private val resetDisabler = BoolValue("§cReset", false) { mode == "Hypixel" }
    val startSprint by boolean("StartSprint", true) { mode == "Normal" }
    private val grimPlace by boolean("GrimPlace", false) { mode == "Normal" }
    private val miniblox by boolean("Miniblox", false) { mode == "Normal" }
    private val vulcanScaffold by boolean("VulcanScaffold", false) { mode == "Normal" }
    private val vulcanPacketTick by int("VulcanScaffoldPacketTick", 15, 1..20) { vulcanScaffold && mode == "Normal" }
    val grimPost by boolean("GrimPost", true) { mode == "Normal" }
    val verusFly by boolean("VerusFly", false) { mode == "Normal" }
    val verusCombat by boolean("VerusCombat", false) { mode == "Normal" }
    val onlyCombat by boolean("OnlyCombat", true) { verusCombat && mode == "Normal" }
    val postPackets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()
    private val intaveFly by boolean("intaveFly", false) { mode == "Normal" }
    private var shouldDelay = false
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()
    private var inAirTicks = 0
    private val noRotationDisabler by boolean("NoRotationDisabler", false) { mode == "Normal" }
    private val modifyMode by choices(
        "Mode",
        arrayOf("ConvertNull", "Spoof", "Zero", "SpoofZero", "Negative", "OffsetYaw", "Invalid"),
        "NoRotationDisabler"
    ) { noRotationDisabler }
    private val offsetAmount by float("OffsetAmount", 6f, -180f..180f) { noRotationDisabler }

    private val cancelC00 by boolean("CancelC00", true) { mode == "Basic" }
    private val cancelC0F by boolean("CancelC0F", true) { mode == "Basic" }
    private val cancelC0A by boolean("CancelC0A", true) { mode == "Basic" }
    private val cancelC0B by boolean("CancelC0B", true) { mode == "Basic" }
    private val cancelC07 by boolean("CancelC07", true) { mode == "Basic" }
    private val cancelC13 by boolean("CancelC13", true) { mode == "Basic" }
    private val cancelC03 by boolean("CancelC03", true) { mode == "Basic" }
    private val c03NoMove by boolean("C03-NoMove", true) { mode == "Basic" }

    private val watchdogMotion by boolean("WatchdogMotion", false) { mode == "Normal" }
    private val notWhenStarAvailable by boolean("NotWithStar", true) { watchdogMotion && mode == "Normal" }

    private val watchdogInventory by boolean("WatchdogInventory", false) { mode == "Normal" }
    private var c16 = false
    private var c0d = false

    val spigotSpam by boolean("SpigotSpam", false) { mode == "Normal" }
    val message by text("Message", "/skill") { spigotSpam && mode == "Normal" }

    private val chatDebug by boolean("ChatDebug", false) { mode == "Normal" }
    private val notificationDebug by boolean("NotificationDebug", false) { mode == "Normal" }

    private var transaction = false
    var isOnCombat = false

    private var flags = 0
    private var execute = false
    private var jump = false

    private val hasStar
        get() = InventoryUtils.findItem(36, 44, Items.nether_star) != null

    private val betaVerus by boolean("VerusBeta", false) { mode == "Normal" }
    private val betaVerusSlientFlagApply by boolean("SlientFlagApply", false) { betaVerus }
    private val betaVerusBufferSize by int("BufferSize", 300, 0..1000) { betaVerus }
    private val betaVerusRepeatTimesValue by int("RepeatTimes", 1, 1..5) { betaVerus }
    private val betaVerusRepeatTimesFighting by int("BRepeatTimesFighting", 1, 1..5) { betaVerus }
    private val betaVerusFlagDelay by int("FlagDelay", 40, 35..60) { betaVerus }

    private var betaVerus2Stat = false
    private var betaVerusModified = false
    private val betaVerusPacketBuffer = LinkedList<Packet<INetHandlerPlayClient>>()
    private var betaVerusLagTimer = MSTimer()

    private val betaVerusRepeatTimes: Int
        get() = if (isOnCombat) betaVerusRepeatTimesFighting else betaVerusRepeatTimesValue

    private val verusExperimental by boolean("VerusExperimental", false) { mode == "Normal" }
    private val verusExpVoidTP by boolean("ExpVoidTP", false) { verusExperimental }
    private val verusExpVoidTPDelay by int("ExpVoidTPDelay", 1000, 0..30000) { verusExpVoidTP }
    private val verusFix by BoolValue("VerusFix", false) { mode == "Normal" }
    private val omniSprint13EValue = BoolValue("VerusFix-OmniSprint", true) { verusFix }
    private val scaffold14EValue = BoolValue("VerusFix-BlockPlace", true) { verusFix }
    private val fly4IValue = BoolValue("VerusFix-Fly4I", true) { verusFix }
    private var verusFixX = 0.0
    private var verusFixY = 0.0
    private var verusFixZ = 0.0
    private var verusFixPitch = 0.0
    private var verusFixYaw = 0.0
    private var verusFixPrevSlot = 0
    private var verusFixJam = 0
    private var verusFixPacketCount = 0
    private var lastVoidTP = 0L
    private var cancelNext = 0
    private var tickCounter = 0
    private var waitingForGround = false
    private var applyingMotion = false
    private var stateTickCounter = 0
    private var warningDisplayed = false
    private var sprintToggleTick = 0
    private var shouldRun = false
    private var lobbyTime: Long = 0
    private var finished: Long = 0
    private var activationDelayMillis: Long = 0
    private val checkDisabledTime: Long = 4000
    private var color = Color(0, 187, 255, 255).rgb
    private var dotAnimationCounter = 0
    private var lastDotUpdate: Long = 0
    private var hasPrintedRunningMessage = false

    private var barWidth = 80f
    private var barHeight = 5f
    private var filledWidth = 0f
    private var barX = 0f
    private var barY = 0f
    private val borderColor = Color(30, 30, 30, 200).rgb
    private var yaw = 0f
    private var pitch = 0f
    private var setRenderYaw = false
    private var setRotations = false
    private var preMotionYaw = 0f
    private var shouldRender = false
    private var firstY = 0.0
    private var reset = false
    private var savedYaw = 0f
    private var savedPitch = 0f
    private var worldJoin = false
    private var wDelay = 0
    var running = false
    var tick: Long = 0
    var cancelTick: Int = 0

    var disablerLoaded = false

    // Disabler.kt 中已有相同功能的方法
    fun setRotations(yaw: Float, pitch: Float) {
        this.yaw = yaw
        this.pitch = pitch
        setRenderYaw = true
        setRotations = true
        preMotionYaw = yaw
    }

    private fun resetState() {
        savedYaw = mc.thePlayer.rotationYaw
        savedPitch = mc.thePlayer.rotationPitch
        shouldRun = true
        tickCounter = 0
        applyingMotion = false
        waitingForGround = true
        stateTickCounter = 0
        warningDisplayed = false
        running = false
        sprintToggleTick = 0
        lobbyTime = System.currentTimeMillis()
        finished = 0
        shouldRender = false
        reset = false
        worldJoin = false
        activationDelayMillis = (activationDelay * 1000).toLong()
        hasPrintedRunningMessage = false
    }

    @SubscribeEvent
    fun onWorldJoin(e: EntityJoinWorldEvent) {
        if (e.entity == mc.thePlayer) {
            resetState()
        }
    }

    @EventTarget
    fun onPacket(event: PacketEvent) {
        val player = mc.thePlayer ?: return
        val packet = event.packet
        if (omniSprint13EValue.get() && packet is C0BPacketEntityAction) {
            event.cancelEvent()
            debugMessage("Packet C0B Cancel")
        }
        if (verusFix) {
            // fix ground check (4I)
            if (packet is C03PacketPlayer && packet !is C04PacketPlayerPosition && packet !is C06PacketPlayerPosLook) {
                if ((player.motionY == 0.0 || (player.onGround && player.isCollidedVertically)) && !packet.onGround) {
                    packet.onGround = true
                    debugMessage("Packet C03 OnGround Fix")
                }
            }

            when (packet) {
                is C04PacketPlayerPosition -> {
                    verusFixX = packet.x
                    verusFixY = packet.y
                    verusFixZ = packet.z
                    verusFixJam = 0
                }

                is C05PacketPlayerLook -> {
                    verusFixYaw = packet.yaw.toDouble()
                    verusFixPitch = packet.pitch.toDouble()
                }

                is C06PacketPlayerPosLook -> {
                    verusFixX = packet.x
                    verusFixY = packet.y
                    verusFixZ = packet.z
                    verusFixJam = 0
                    verusFixYaw = packet.yaw.toDouble()
                    verusFixPitch = packet.pitch.toDouble()
                }
            }
            // 处理普通C03包
            if (packet is C03PacketPlayer && packet !is C04PacketPlayerPosition && packet !is C06PacketPlayerPosLook) {
                verusFixJam++
                if (verusFixJam > 20) {
                    verusFixJam = 0
                    event.cancelEvent()
                    sendPacket(
                        C06PacketPlayerPosLook(
                            verusFixX,
                            verusFixY,
                            verusFixZ,
                            verusFixYaw.toFloat(),
                            verusFixPitch.toFloat(),
                            packet.onGround
                        )
                    )
                    debugMessage("Packet C03 Spam Fix")
                }
            }
            if (scaffold14EValue.get() && packet is C08PacketPlayerBlockPlacement) {
                ReflectionUtil.setFieldValue(
                    packet,
                    "facingX",
                    (ReflectionUtil.getFieldValue<Float>(packet, "facingX")).coerceIn(-1.0f..1.0f)
                )
                ReflectionUtil.setFieldValue(
                    packet,
                    "facingY",
                    (ReflectionUtil.getFieldValue<Float>(packet, "facingY")).coerceIn(-1.0f..1.0f)
                )
                ReflectionUtil.setFieldValue(
                    packet,
                    "facingZ",
                    (ReflectionUtil.getFieldValue<Float>(packet, "facingZ")).coerceIn(-1.0f..1.0f)
                )
                debugMessage("Packet C08 Placement Fix")
            }
            // 处理重复的C09包
            if (packet is C09PacketHeldItemChange) {
                if (packet.slotId == verusFixPrevSlot) {
                    event.cancelEvent()
                    debugMessage("Packet C09 Duplicate Cancel")
                } else {
                    verusFixPrevSlot = packet.slotId
                }
            }


            // 处理Fly4I
            if (fly4IValue.get() && packet is C03PacketPlayer && !packet.onGround) {
                if (packet !is C04PacketPlayerPosition && packet !is C05PacketPlayerLook && packet !is C06PacketPlayerPosLook) {
                    verusFixPacketCount++
                    if (verusFixPacketCount >= 2) {
                        event.cancelEvent()
                        debugMessage("Packet C03 Flying Cancel")
                    }
                } else {
                    verusFixPacketCount = 0
                }
            }
        }
        if (mode == "Basic") {
            when (packet) {
                is C00PacketKeepAlive -> if (cancelC00) {
                    event.cancelEvent()
                    debugMessage("Cancel C00-KeepAlive")
                }

                is C0FPacketConfirmTransaction -> if (cancelC0F) {
                    event.cancelEvent()
                    debugMessage("Cancel C0F-Transaction")
                }

                is C0APacketAnimation -> if (cancelC0A) {
                    event.cancelEvent()
                    debugMessage("Cancel C0A-Swing")
                }

                is C0BPacketEntityAction -> if (cancelC0B) {
                    event.cancelEvent()
                    debugMessage("Cancel C0B-Action")
                }

                is C07PacketPlayerDigging -> if (cancelC07) {
                    event.cancelEvent()
                    debugMessage("Cancel C07-Digging")
                }

                is C13PacketPlayerAbilities -> if (cancelC13) {
                    event.cancelEvent()
                    debugMessage("Cancel C13-Abilities")
                }

                is C03PacketPlayer -> if (cancelC03 && !(packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook)) {
                    if (c03NoMove && player.isMoving) return
                    event.cancelEvent()
                    debugMessage("Cancel C03-Flying")
                }
            }
        }

        // NoRotationDisabler
        if (noRotationDisabler && packet is C03PacketPlayer) {
            when (modifyMode) {
                "ConvertNull" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C04PacketPlayerPosition(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(C03PacketPlayer(packet.onGround))
                    }
                    event.cancelEvent()
                }

                "Spoof" -> {
                    if (packet.getRotating()) {
                        packet.yaw = player.rotationYaw
                        packet.pitch = player.rotationPitch
                    }
                }

                "Zero" -> {
                    if (packet.getRotating()) {
                        packet.yaw = 0.0f
                        packet.pitch = 0.0f
                    }
                }

                "SpoofZero" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(
                            C06PacketPlayerPosLook(
                                player.posX,
                                player.posY,
                                player.posZ,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    }
                    event.cancelEvent()
                }

                "Negative" -> {
                    if (packet.getRotating()) {
                        packet.yaw = -packet.yaw
                        packet.pitch = -packet.pitch
                    }
                }

                "OffsetYaw" -> {
                    if (packet.getRotating()) {
                        packet.yaw += offsetAmount
                    }
                }
            }
        }

        /**
         * Working on Hypixel (Watchdog)
         * Tested on: play.hypixel.net
         * Credit: @localp / Nextgen
         * Original: @billionaire
         */
        if (watchdogMotion) {
            when (packet) {
                is S07PacketRespawn -> {
                    flags = 0
                    execute = false
                    jump = true
                }

                is S08PacketPlayerPosLook -> {
                    if (++flags >= 20) {
                        execute = false
                        flags = 0
                    }
                }
            }
        }

        // Watchdog Inventory
        if (watchdogInventory) {
            if (packet is C16PacketClientStatus) {
                if (c16) {
                    event.cancelEvent()
                }
                c16 = true
            }
            if (packet is C0DPacketCloseWindow) {
                if (c0d) {
                    event.cancelEvent()
                }
                c0d = true
            }
        }

        // Grim Place
        if (grimPlace) {
            if (packet is C08PacketPlayerBlockPlacement && packet.placedBlockDirection in 0..5) {
                event.cancelEvent()
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        6 + packet.placedBlockDirection * 7,
                        packet.stack,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )
                debugMessage("§cModify §aPlace §cPacket§7.")
            }
        }
        // Miniblox Disabler
        if (miniblox && packet is S08PacketPlayerPosLook && player.ticksExisted >= 100) {
            event.cancelEvent()
            debugMessage("§cProcessing Miniblox Position Correction")

            // 发送服务器修正后的坐标 + 玩家当前视角
            sendPacket(
                C06PacketPlayerPosLook(
                    packet.x,
                    packet.y,
                    packet.z,
                    player.rotationYaw,
                    player.rotationPitch,
                    player.onGround
                ), false
            )

            // 发送玩家当前真实坐标 + 视角
            sendPacket(
                C06PacketPlayerPosLook(
                    player.posX,
                    player.posY,
                    player.posZ,
                    player.rotationYaw,
                    player.rotationPitch,
                    player.onGround
                ), false
            )
        }
        // Intave Fly
        if (intaveFly) {
            if (packet is S08PacketPlayerPosLook) {
                if (player.capabilities.isFlying) {
                    shouldDelay = true
                    debugMessage("§cStart Canceling IntaveFly")
                }
            }

            if (packet is S32PacketConfirmTransaction && shouldDelay) {
                event.cancelEvent()
                packets.add(packet as Packet<INetHandlerPlayClient>)
            }
        }

        // Verus Combat
        if (verusCombat) {
            if (player.ticksExisted <= 20) {
                isOnCombat = false
                return
            }

            if (onlyCombat && !isOnCombat) {
                return
            }

            /**
             * Works by just simply ignore transaction and not accepting them and send invalid one
             * to bypass Verus cancel transaction "patch" (not sending transaction for too long)
             * This could work on other anti-cheat that don't have a proper transaction handling system
             * But this will mostly be used on Verus, disabled any combat check related to transaction.
             *
             * Credit: @ghost / LB Nextgen
             */
            if (packet is S32PacketConfirmTransaction) {
                event.cancelEvent()
                sendPacket(
                    C0FPacketConfirmTransaction(
                        if (transaction) 1 else -1,
                        if (transaction) -1 else 1,
                        transaction
                    ), triggerEvent = false
                )
                transaction = !transaction
            }

            isOnCombat = false
        }

        if (betaVerus) {
            if (packet is C0FPacketConfirmTransaction) {
                betaVerusPacketBuffer.add(packet as Packet<INetHandlerPlayClient>)
                event.cancelEvent()
                if (betaVerusPacketBuffer.size > betaVerusBufferSize) {
                    if (!betaVerus2Stat) {
                        betaVerus2Stat = true
                        hud.addNotification(Notification("AntiCheat is disabled.", 2000F))
                    }
                    val packeted = betaVerusPacketBuffer.poll()
                    repeat(betaVerusRepeatTimes) {
                        sendPacket(packeted, false)
                    }
                }
                debugMessage("Packet C0F IN BufferSize=${betaVerusPacketBuffer.size}")
            } else if (packet is C03PacketPlayer) {
                if (player.ticksExisted % betaVerusFlagDelay == 0 && player.ticksExisted > betaVerusFlagDelay + 1 && !betaVerusModified) {
                    debugMessage("Packet C03 -> BetaVerus Y offset")
                    betaVerusModified = true
                    packet.y -= 11.4514
                    packet.onGround = false
                }
            } else if (packet is S08PacketPlayerPosLook && betaVerusSlientFlagApply) {
                val x = packet.x - player.posX
                val y = packet.y - player.posY
                val z = packet.z - player.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    debugMessage("Silent Flag")
                    sendPacket(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.yaw,
                            packet.pitch,
                            true
                        ),
                        false
                    )
                }
            }
            if (player.ticksExisted <= 7) {
                betaVerusLagTimer.reset()
                betaVerusPacketBuffer.clear()
            }
        }

        // Verus Experimental
        if (verusExperimental) {
            if (verusExpVoidTP && packet is C03PacketPlayer) {
                if (player.ticksExisted > 20 && player.posY > -64) {
                    if (lastVoidTP + verusExpVoidTPDelay < System.currentTimeMillis()) {
                        lastVoidTP = System.currentTimeMillis()
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                -48.0,
                                player.posZ,
                                true
                            )
                        )
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                player.posY,
                                player.posZ,
                                false
                            )
                        )
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                player.posY,
                                player.posZ,
                                player.onGround
                            )
                        )
                        cancelNext = 2
                        event.cancelEvent()
                        debugMessage("VerusExp VoidTP attempt")
                    }
                }
            } else if (verusExpVoidTP && packet is S08PacketPlayerPosLook && cancelNext > 0) {
                cancelNext--
                event.cancelEvent()
                debugMessage("VerusExp canceled server position look")
            }
        }
    }

    @EventTarget
    fun onJump(event: JumpEvent) {
        if (!watchdogMotion) return

        if (event.eventState == EventState.POST) {
            if (!jump) return
            jump = false
            execute = true
        }
    }

    @EventTarget
    fun onMotion(event: MotionEvent) {
        if (mode == "Normal") {
            val player = mc.thePlayer ?: return
            if (!watchdogMotion) return
            if (event.eventState != EventState.PRE) return
            if (notWhenStarAvailable && hasStar) return

            if (execute && airTicks >= 10) {
                if (airTicks % 2 == 0) {
                    event.x += 0.095
                }
                player.setVelocity(0.0, 0.0, 0.0)
            }
        } else if (mode == "Hypixel") {
            if (mc.thePlayer.onGround) {
                inAirTicks = 0
            } else {
                inAirTicks++
            }
            if (event.eventState.stateName != "PRE") return
            if (resetDisabler.get()) {
                WaterMark.showIconNotification("Disabler", "Disabler resetting...", ResourceLocation("liquidbounce/notification/v.png"))
                resetState()
                disablerLoaded = false
                resetDisabler.set(false)
            }

            if (getLobbyStatus() == 1 || hypixelStatus() != 1 || isReplay()) {
                return
            }

            val now = System.currentTimeMillis()
            if (finished != 0L && mc.thePlayer.onGround && now - finished > checkDisabledTime) {
                WaterMark.showIconNotification("Disabler", "Disabler finished!", ResourceLocation("liquidbounce/notification/enabled.png"))
                finished = 0
                filledWidth = 0f
                disablerLoaded = true
            }

            if (!shouldRun) {
                return
            }

            if (now - lobbyTime < activationDelayMillis) {
                return
            }

            running = true
            mc.thePlayer.rotationYaw = 0F
            mc.thePlayer.rotationPitch = savedPitch

            if (waitingForGround) {
                if (mc.thePlayer.onGround) {
                    mc.thePlayer.motionY = 0.42
                    waitingForGround = false
                    worldJoin = false
                }
                return
            }

            if (inAirTicks >= 10 || worldJoin && ++wDelay >= 3) {
                if (!applyingMotion) {
                    applyingMotion = true
                    firstY = mc.thePlayer.posY
                }

                if (tickCounter < disablerTicks) {
                    if (!hasPrintedRunningMessage) {
                        WaterMark.showIconNotification("Disabler", "Disabler running...", ResourceLocation("liquidbounce/notification/boots.png"))
                        hasPrintedRunningMessage = true
                    }
                    shouldRender = true

                    mc.thePlayer.motionX = 0.0
                    mc.thePlayer.motionY = 0.0
                    mc.thePlayer.motionZ = 0.0

                    if (mc.thePlayer.posY != firstY) {
                        if (!reset) {
                            resetState()
                            activationDelayMillis = 2000
                            reset = true
                            chat("Disabler reset, wait a few seconds...")
                        } else {
                            shouldRun = false
                            applyingMotion = false
                            running = false
                            chat("Failed to reset disabler, please try again!")
                        }
                    }

                    if (mc.thePlayer.ticksExisted % 2 == 0) {
                        mc.thePlayer.posZ += 0.075
                        mc.thePlayer.posX += 0.075
                    }

                    tickCounter++
                } else if (!warningDisplayed) {
                    val totalTimeSeconds = (now - lobbyTime) / 1000.0
                    warningDisplayed = true
                    finished = now
                    shouldRender = false
                    shouldRun = false
                    applyingMotion = false
                    running = false
                }
            }

            filledWidth = barWidth * tickCounter / disablerTicks
            val scaledResolution = ScaledResolution(mc)
            barX = scaledResolution.scaledWidth / 2f - barWidth / 2
            barY = scaledResolution.scaledHeight / 2f + 28
        }
    }

    @EventTarget
    fun onMoveInput(event: MovementInputEvent) {
        if (!running || isReplay()) {
            return
        }
        event.originalInput.moveForward = 0f
        event.originalInput.moveStrafe = 0f
        mc.thePlayer.movementInput.jump = false
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        val player = mc.thePlayer ?: return

        // watchdogMotion jump
        if (watchdogMotion) {
            if (jump) {
                player.tryJump()
            }
        }

        // Watchdog Inventory
        if (watchdogInventory) {
            c16 = false
            c0d = false
            if (mc.currentScreen is GuiInventory) {
                if (player.ticksExisted % (if (player.isPotionActive(Potion.moveSpeed)) 3 else 4) == 0) {
                    sendPacket(C0DPacketCloseWindow(), false)
                } else if (player.ticksExisted % (if (player.isPotionActive(Potion.moveSpeed)) 3 else 4) == 1) {
                    sendPacket(C16PacketClientStatus(C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT), false)
                }
            }
        }

        // Verus Fly
        if (verusFly) {
            if (!isOnCombat && !player.isDead) {
                val pos = player.position.add(0, if (player.posY > 0) -255 else 255, 0) ?: return
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        pos,
                        256,
                        ItemStack(Items.water_bucket),
                        0F,
                        0.5F + Math.random().toFloat() * 0.44F,
                        0F
                    )
                )
            } else {
                isOnCombat = false
            }
        }

        // Vulcan Scaffold
        if (vulcanScaffold) {
            if (!(player.isInLiquid || player.isDead || player.isOnLadder)) {
                if (player.isMoving && player.ticksExisted % vulcanPacketTick == 0) {
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.START_SNEAKING))
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.STOP_SNEAKING))
                }
            }
        }

        if (betaVerus) {
            betaVerusModified = false
            if (betaVerusLagTimer.hasTimePassed(490L)) {
                betaVerusLagTimer.reset()
                if (betaVerusPacketBuffer.isNotEmpty()) {
                    val packet = betaVerusPacketBuffer.poll()
                    repeat(betaVerusRepeatTimes) {
                        sendPacket(packet, false)
                    }
                    debugMessage("Send Packet Buff")
                } else {
                    debugMessage("Empty Packet Buff")
                }
            }
        }
    }

    @EventTarget
    fun onAttack(event: AttackEvent) {
        isOnCombat = true
    }

    @EventTarget
    fun onWorld(event: WorldEvent) {
        isOnCombat = false
        if (betaVerus) {
            betaVerus2Stat = false
            betaVerusPacketBuffer.clear()
            betaVerusLagTimer.reset()
        }
    }

    fun nullCheck(): Boolean {
        return mc.thePlayer != null && mc.theWorld != null
    }

    fun getSidebarLines(): MutableList<String> {
        val lines: MutableList<String> = ArrayList<String>()
        if (mc.theWorld == null) {
            return lines
        }
        val scoreboard: Scoreboard? = mc.theWorld.getScoreboard()
        if (scoreboard == null) {
            return lines
        }
        val objective = scoreboard.getObjectiveInDisplaySlot(1)
        if (objective == null) {
            return lines
        }
        var scores = scoreboard.getSortedScores(objective)
        val list: MutableList<Score?> = ArrayList<Score?>()
        for (input in scores) {
            if (input != null && input.getPlayerName() != null && !input.getPlayerName().startsWith("#")) {
                list.add(input)
            }
        }
        if (list.size > 15) {
            scores = ArrayList<Score?>(Lists.newArrayList<Score?>(Iterables.skip<Score?>(list, list.size - 15)))
        } else {
            scores = list
        }
        var index = 0
        for (score in scores) {
            ++index
            val team = scoreboard.getPlayersTeam(score!!.getPlayerName())
            lines.add(ScorePlayerTeam.formatPlayerName(team, score.getPlayerName()))
            if (index == scores.size) {
                lines.add(objective.getDisplayName())
            }
        }
        Collections.reverse(lines)
        return lines
    }

    fun stripString(s: String?): String {
        val nonValidatedString = StringUtils.stripControlCodes(s).toCharArray()
        val validated = StringBuilder()
        for (c in nonValidatedString) {
            if (c < '' && c > '') {
                validated.append(c)
            }
        }
        return validated.toString()
    }

    fun getLobbyStatus(): Int {
        if (!nullCheck()) {
            return -1
        }
        val scoreboard: Scoreboard? = mc.theWorld.getScoreboard()
        if (scoreboard == null) {
            return -1
        }
        val objective = scoreboard.getObjectiveInDisplaySlot(1)
        if (objective == null) {
            return -1
        }
        for (line in getSidebarLines()) {
            var line: String? = line
            line = stripString(line)
            val parts = line!!.split("  ".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            if (parts.size > 1) {
                if (parts[1].startsWith("L")) {
                    return 1
                }
            }
        }
        return -1
    }

    fun hypixelStatus(): Int {
        if (!nullCheck()) {
            return -1
        }
        val scoreboard: Scoreboard? = mc.theWorld.getScoreboard()
        if (scoreboard == null) {
            return -2
        }
        val objective = scoreboard.getObjectiveInDisplaySlot(1)
        if (objective == null) {
            return -1
        }
        for (line in getSidebarLines()) {
            var line: String? = line
            line = stripString(line)
            if (line!!.startsWith("0") || line.startsWith("1")) {
                return 1
            }
        }
        return -1
    }

    fun isHypixel(): Boolean {
        return true
    }

    fun isReplay(): Boolean {
        if (isHypixel()) {
            if (!nullCheck()) {
                return false
            }
            val scoreboard: Scoreboard? = mc.theWorld.getScoreboard()
            if (scoreboard == null) {
                return false
            }
            val objective = scoreboard.getObjectiveInDisplaySlot(1)
            if (objective == null || !stripString(objective.getDisplayName())
                    .contains("REPLAY")
            ) {
                return false
            }
            return true
        }
        return false
    }

    override fun onEnable() {
        if (!disablerLoaded) {
            resetState()
        }

        val scaledResolution = ScaledResolution(mc)
        barX = scaledResolution.scaledWidth / 2f - barWidth / 2
        barY = scaledResolution.scaledHeight / 2f + 28
    }

    override fun onDisable() {
        shouldRun = false
        running = false
    }

    private fun debugMessage(msg: String) {
        if (chatDebug) {
            chat("§f$msg")
        }
        if (notificationDebug) {
            hud.addNotification(Notification("§f$msg", 1000F))
        }
    }

    @EventTarget
    fun onRender2D(ev: Render2DEvent) {
        if (nullCheck() || mc.currentScreen != null || !shouldRun || !shouldRender) return

        if (System.currentTimeMillis() - lastDotUpdate > 333) {
            dotAnimationCounter = (dotAnimationCounter + 1) % 4
            lastDotUpdate = System.currentTimeMillis()
        }
    }

    private fun drawRoundedRect(x: Float, y: Float, x2: Float, y2: Float, radius: Float, color: Int) {
        glEnable(GL_BLEND)
        glDisable(GL_TEXTURE_2D)
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA)

        val alpha = (color shr 24 and 0xFF) / 255.0f
        val red = (color shr 16 and 0xFF) / 255.0f
        val green = (color shr 8 and 0xFF) / 255.0f
        val blue = (color and 0xFF) / 255.0f
        glColor4f(red, green, blue, alpha)

        glBegin(GL_POLYGON)
        for (i in 0..90 step 30) {
            val rad = Math.toRadians(i.toDouble()).toFloat()
            glVertex2f(x + radius + cos(rad) * radius, y + radius + sin(rad) * radius)
        }
        glEnd()

        glEnable(GL_TEXTURE_2D)
        glDisable(GL_BLEND)
    }

    private fun drawGradientRect(left: Float, top: Float, right: Float, bottom: Float, startColor: Int, endColor: Int) {
        glEnable(GL_BLEND)
        glDisable(GL_TEXTURE_2D)
        glShadeModel(GL_SMOOTH)

        glBegin(GL_QUADS)
        glColor4f(
            (startColor shr 16 and 0xFF) / 255.0f,
            (startColor shr 8 and 0xFF) / 255.0f,
            (startColor and 0xFF) / 255.0f,
            (startColor shr 24 and 0xFF) / 255.0f
        )
        glVertex2f(left, top)
        glVertex2f(left, bottom)

        glColor4f(
            (endColor shr 16 and 0xFF) / 255.0f,
            (endColor shr 8 and 0xFF) / 255.0f,
            (endColor and 0xFF) / 255.0f,
            (endColor shr 24 and 0xFF) / 255.0f
        )
        glVertex2f(right, bottom)
        glVertex2f(right, top)
        glEnd()

        glShadeModel(GL_FLAT)
        glEnable(GL_TEXTURE_2D)
        glDisable(GL_BLEND)
    }


    private val disablerTicks: Int
        get() = if (hypixelMode) 130 else 140

    private fun adjustColor(original: Int, amount: Int): Int {
        val r = ((original shr 16 and 0xFF) + amount).coerceIn(0, 255)
        val g = ((original shr 8 and 0xFF) + amount).coerceIn(0, 255)
        val b = ((original and 0xFF) + amount).coerceIn(0, 255)
        return (original and -0x1000000) or (r shl 16) or (g shl 8) or b
    }

    fun releasePost() {
        if (grimPost && state && mc.netHandler != null) {
            while (!postPackets.isEmpty()) {
                val packetEvent = PacketEvent(postPackets.poll(), EventState.RECEIVE)
                EventManager.callEvent(packetEvent)
                if (packetEvent.isCancelled) {
                    continue  // 跳过已取消的事件，继续处理下一个包
                }
                val packet = packetEvent.packet as? Packet<INetHandlerPlayClient?> ?: continue
                try {
                    packet.processPacket(mc.netHandler)
                    PPSCounter.registerType(PPSCounter.PacketType.RECEIVED)
                } catch (e: Exception) {
                    // 记录异常或调试信息
                    e.printStackTrace()
                }
            }
        }
    }
}
